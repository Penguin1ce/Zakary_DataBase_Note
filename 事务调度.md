## 1. 事务调度

### 1.1 事务调度的准则

（1）一组事务的调度必须保证： 包含了所有事务的操作指令；一个事务内部的指令顺序必须保持不变 

（2）并行事务调度必须保证： 可串性化，将所有可能的串行调度结果推演一遍，对于某个具体的并行调度再执行一遍，看是否能与某个串行调度的结果相同 

（3）判断可串性化的充分条件：冲突可串性化（冲突可串性化一定是可串 性化调度，但可串性化调度不一定是冲突可串性化） 

冲突操作：不同事务对同一数据分别进行读和写；不同事务对同一数据分别进行写和写冲突可串性化调度即不交换不同事务的冲突操作次序，也不交换同一事务的 两个操作的次序。但可以交换不同事务对不同数据各种操作次序，也可以交换不同事务对同一数据的读取操作次序

### 1.2  封锁

（1）X锁：写锁，某事务对数据对象上锁后，可读取和修改该数据对象，其 他事务不可再对该数据对象添加锁 表示方法：上锁Xlock( ) 释放锁Unlock( ) 

（2）S锁：读锁，某事务对数据对象上锁后，可读取但不可修改该数据对象，其他事务可以对该数据对象添加S锁，但不能添加X锁表示方法：上锁Slock( ) 释放锁Unlock( ) 

（3）封锁协议

一级封锁协议：写前加写锁，事务结束释放写锁；可防止丢失修改

二级封锁协议：写前加写锁，读前加读锁，读完释放读锁，事务结束释放写锁；可防止丢失修改和读脏数据

三级封锁协议（常用：支持一致性维护）：写前加写锁，读前加读锁，事务 结束释放各锁；可防止丢失修改、读脏数据和不可重复读

如果所有事务均遵循三级封锁协议，由于其隔离级别高，那么这些事务无论 怎样交叉并行，都是可串性化的调度

（4）两段锁协议（2PL） 

三级封锁协议可以保证并发操作的正确性，但由于其太过严苛，对并发度有负面影响。三级封锁协议实际是两段锁协议的特例，是更严格的两段锁协议 

两段锁协议要求：事务在对任何数据进行读写前，需要获得对该数据的封锁；而当事务在释放任何一个封锁后，不可再获得任何其他封锁事务。

遵循两段锁协议是可串性化的充分条件，遵循两段锁协议是可能发生死锁的



## S锁和X锁

S锁（Shared Lock，共享锁）是数据库管理系统中常用的一种锁类型，通常用于保证数据的一致性和并发控制。S锁允许多个事务同时读取数据，但不允许事务对数据进行修改。具体来说，S锁的特点是：

1. **共享访问：** 拥有S锁的事务可以读取数据，但不能修改数据。
2. **并发执行：** 允许多个事务同时对同一数据行加S锁，这样这些事务可以并发地读取数据。
3. **阻止写操作：** 如果一个事务已经持有S锁，其他事务不能对数据进行修改操作（不能加X锁，独占锁），除非持有S锁的事务释放锁。

S锁通常与X锁（Exclusive Lock）配合使用，在事务管理中通过加锁机制来避免出现诸如脏读、不可重复读和幻读等问题。

### S锁的用途

- **并发读取：** 当多个事务需要读取同一数据，但不需要修改数据时，S锁允许多个事务共享访问该数据，增加并发性。
- **保证一致性：** S锁确保数据不会被修改，防止在读取数据时出现不一致的情况。

举个例子：

- **事务T1** 和 **事务T2** 都希望读取某一行数据（例如用户信息），它们可以同时对该行数据加S锁，允许它们并行读取数据。
- 但如果**事务T3** 需要修改该行数据，那么它就必须加一个X锁，且它不能与其他事务同时加锁。

X锁（Exclusive Lock，排他锁）是一种数据库锁类型，它用于确保在事务进行某项操作时，其他事务无法对同一数据项进行读写操作。具体来说，X锁的特点是：

- **排他性**：当一个事务对某个数据项加上X锁时，其他事务不能对该数据项进行任何操作，包括读取和写入，直到该锁被释放。
- **写操作**：X锁通常用于执行写操作（如INSERT、UPDATE、DELETE），因为它确保在写操作期间没有其他事务能访问该数据。

### X锁与S锁的区别：

- **S锁**：允许多个事务同时对数据项进行读取，但不允许写入。
- **X锁**：只允许一个事务对数据项进行操作，且该事务对数据的操作是排他的，其他事务不能进行读取或写入。

X锁通常用于保护数据的完整性，尤其是在需要修改数据时，确保其他事务无法在此期间访问这些数据。



关系数据结构的基本数据结构就是由**元组**、**属性**和**域**构成的**关系**。

## 范式的判断

**部分依赖**通常发生在复合主键情况下，非主属性仅依赖于主键的一部分。

**第三范式（3NF）的定义要求关系中的每个非主属性不仅完全依赖于主键（没有部分依赖），而且必须直接依赖**于主键，不能依赖于其他非主属性（即不存在传递依赖）。

### 具体解释：

1. **符合2NF**：首先，关系必须满足**第二范式（2NF）**，也就是说，所有的非主属性必须完全依赖于主键，而不是依赖于主键的部分属性。
2. **消除传递依赖**：在3NF中，关系还要求非主属性不能传递依赖于主键。换句话说，如果有一个属性 `A` 依赖于主键 `P`，而属性 `B` 依赖于 `A`，那么为了满足3NF，`B` 必须直接依赖于 `P`，否则就违反了3NF。

### 例子：

假设有一个关系 `R` (A, B, C)，其中：

- A 是主键。
- B 依赖于 A（B → A）。
- C 依赖于 A（C → A）。
- 但 C 也依赖于 B（C → B）。

此时，`C` 依赖于 `B`，而 `B` 又依赖于 `A`。这种情况就构成了**传递依赖**（A → B → C）。

为了使这个关系满足第三范式，我们需要消除这种传递依赖。可以通过将 `C` 和 `B` 分到不同的关系中来解决这个问题，从而确保每个非主属性直接依赖于主键，而不通过其他非主属性。

### 总结：

- **3NF** 要求每个非主属性必须直接依赖于主键，而不能通过其他非主属性传递依赖。
- **去除传递依赖**是3NF的关键要求。

### 流程：

1.先求候选键

2.非键属性**是否部分依赖于候选键**，如果是：1NF

如果否：2NF

3.非键属性**是否传递依赖于候选键**，如果是：2NF

如果否：3NF

4.判断所有依赖项的**左边是否全为候选键**。如果是：BNF

如果否：3NF



ABCD

AB->D 注意完全依赖和部分依赖

直接导出

### 最小函数依赖集

1.先拆右边

A->BC   变成    A->B    A->C

2.再拆左边

